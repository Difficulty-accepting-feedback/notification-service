[
  {
    "question": "자바 프로그램의 시작점이 되는 메서드는?",
    "choices": [
      "start(String[] args)",
      "main(String[] args)",
      "run(String[] args)",
      "execute(String[] args)"
    ],
    "answer": "main(String[] args)",
    "explanation": "자바 애플리케이션은 public static void main(String[] args) 메서드에서 시작한다.",
    "level": "EASY",
    "categoryId": 1
  },
  {
    "question": "자바에서 문자열을 표현하는 클래스는?",
    "choices": ["String", "Text", "Chars", "BufferString"],
    "answer": "String",
    "explanation": "문자열은 java.lang.String 클래스로 표현되며 불변(immutable)이다.",
    "level": "EASY",
    "categoryId": 1
  },
  {
    "question": "자바에서 한 줄 주석을 시작하는 기호는?",
    "choices": ["/*", "//", "#", "<!--"],
    "answer": "//",
    "explanation": "한 줄 주석은 //, 여러 줄 주석은 /* ... */ 형식을 사용한다.",
    "level": "EASY",
    "categoryId": 1
  },
  {
    "question": "int형 변수의 기본 초기값(필드 기준)은?",
    "choices": ["0", "null", "undefined", "1"],
    "answer": "0",
    "explanation": "클래스 필드(멤버 변수)의 int 기본값은 0이다. 지역 변수는 반드시 초기화해야 한다.",
    "level": "EASY",
    "categoryId": 1
  },
  {
    "question": "자바에서 배열의 인덱스는 몇부터 시작하는가?",
    "choices": ["0", "1", "-1", "2"],
    "answer": "0",
    "explanation": "자바 배열은 0부터 시작한다.",
    "level": "EASY",
    "categoryId": 1
  },
  {
    "question": "자동 박싱/언박싱과 관련된 래퍼 타입 중 int에 해당하는 것은?",
    "choices": ["Integer", "Int", "Number", "Long"],
    "answer": "Integer",
    "explanation": "기본형 int의 래퍼 타입은 Integer다. 자동 박싱/언박싱을 지원한다.",
    "level": "EASY",
    "categoryId": 1
  },
  {
    "question": "자바에서 논리형(boolean)의 가능한 값은?",
    "choices": ["true/false", "0/1", "yes/no", "on/off"],
    "answer": "true/false",
    "explanation": "자바의 boolean은 true와 false 두 값만 가진다.",
    "level": "EASY",
    "categoryId": 1
  },
  {
    "question": "다음 중 자바의 기본형(primitive)이 아닌 것은?",
    "choices": ["int", "double", "String", "boolean"],
    "answer": "String",
    "explanation": "String은 참조형(클래스)이며 기본형이 아니다.",
    "level": "EASY",
    "categoryId": 1
  },
  {
    "question": "자바에서 상수를 선언할 때 주로 사용하는 키워드는?",
    "choices": ["final", "const", "static", "let"],
    "answer": "final",
    "explanation": "자바에서 상수는 보통 public static final로 선언한다. const는 예약어이지만 사용되지 않는다.",
    "level": "EASY",
    "categoryId": 1
  },
  {
    "question": "switch 문에서 조건에 사용할 수 없는 타입은(자바 7 기준)?",
    "choices": ["int", "String", "enum", "float"],
    "answer": "float",
    "explanation": "자바 7부터 String, enum, 정수 계열 가능하지만 float/double은 사용할 수 없다.",
    "level": "EASY",
    "categoryId": 1
  },
  {
    "question": "자바에서 패키지를 선언할 때 사용하는 키워드는?",
    "choices": ["package", "namespace", "module", "group"],
    "answer": "package",
    "explanation": "소스 파일의 최상단에 package 키워드로 패키지를 선언한다.",
    "level": "EASY",
    "categoryId": 1
  },
  {
    "question": "System.out.println에서 println의 역할은?",
    "choices": ["입력", "출력", "파일저장", "네트워크전송"],
    "answer": "출력",
    "explanation": "표준 출력 스트림(System.out)에 줄바꿈을 포함하여 출력한다.",
    "level": "EASY",
    "categoryId": 1
  },
  {
    "question": "다음 중 자바 예약어는?",
    "choices": ["public", "main", "print", "varname"],
    "answer": "public",
    "explanation": "public, class, static 등은 자바 예약어다.",
    "level": "EASY",
    "categoryId": 1
  },
  {
    "question": "문자 하나를 저장하는 기본형 타입은?",
    "choices": ["char", "character", "string", "text"],
    "answer": "char",
    "explanation": "char는 16비트 유니코드 문자를 저장한다.",
    "level": "EASY",
    "categoryId": 1
  },
  {
    "question": "자바에서 클래스와 파일 이름이 같아야 하는 경우는?",
    "choices": [
      "모든 클래스",
      "public 클래스",
      "private 클래스",
      "추상 클래스"
    ],
    "answer": "public 클래스",
    "explanation": "하나의 소스 파일에 public 클래스가 있으면 파일명은 그 public 클래스명과 같아야 한다.",
    "level": "EASY",
    "categoryId": 1
  },
  {
    "question": "연산자 우선순위에서 ++i 와 i++의 차이는?",
    "choices": [
      "둘 다 같다",
      "전위는 먼저 증가, 후위는 나중 증가",
      "후위가 먼저 증가",
      "전위는 감소"
    ],
    "answer": "전위는 먼저 증가, 후위는 나중 증가",
    "explanation": "전위 증감은 사용 전 증가, 후위 증감은 사용 후 증가한다.",
    "level": "EASY",
    "categoryId": 1
  },
  {
    "question": "배열 길이를 얻는 방법은?",
    "choices": ["arr.length()", "arr.size()", "arr.length", "length(arr)"],
    "answer": "arr.length",
    "explanation": "자바 배열의 길이는 필드 length로 제공된다(메서드 아님).",
    "level": "EASY",
    "categoryId": 1
  },
  {
    "question": "문자열 비교에 == 대신 써야 하는 메서드는?",
    "choices": ["compare()", "equals()", "same()", "match()"],
    "answer": "equals()",
    "explanation": "문자열 내용 비교는 equals()를 사용한다. ==는 참조 비교다.",
    "level": "EASY",
    "categoryId": 1
  },
  {
    "question": "자바에서 개행을 의미하는 이스케이프 문자는?",
    "choices": ["\\t", "\\n", "\\r", "\\\\"],
    "answer": "\\n",
    "explanation": "개행(new line)은 \\n, 탭은 \\t, 캐리지 리턴은 \\r 이다.",
    "level": "EASY",
    "categoryId": 1
  },
  {
    "question": "자바의 패키지 임포트에 사용하는 키워드는?",
    "choices": ["include", "using", "import", "require"],
    "answer": "import",
    "explanation": "다른 패키지의 클래스를 사용할 때 import를 사용한다.",
    "level": "EASY",
    "categoryId": 1
  },

  {
    "question": "오버로딩과 관련하여 옳은 설명은?",
    "choices": [
      "같은 이름의 메서드를 매개변수 다르게 정의",
      "상속받은 메서드 재정의",
      "추상 메서드 구현",
      "정적 메서드만 사용"
    ],
    "answer": "같은 이름의 메서드를 매개변수 다르게 정의",
    "explanation": "오버로딩은 동일 이름, 매개변수 시그니처가 다른 메서드를 여러 개 정의하는 것.",
    "level": "NORMAL",
    "categoryId": 1
  },
  {
    "question": "오버라이딩의 조건으로 옳지 않은 것은?",
    "choices": [
      "메서드 이름 동일",
      "매개변수 목록 동일",
      "반환 타입 완전히 무관",
      "접근 제어자는 더 넓게 가능"
    ],
    "answer": "반환 타입 완전히 무관",
    "explanation": "오버라이딩은 시그니처 동일, 반환 타입은 공변 반환 가능. 완전히 무관하지 않다.",
    "level": "NORMAL",
    "categoryId": 1
  },
  {
    "question": "다형성을 가장 잘 설명하는 것은?",
    "choices": [
      "하나의 타입 참조로 다양한 실제 객체를 다룬다",
      "하나의 객체에 여러 필드를 넣는다",
      "여러 스레드를 동시에 실행",
      "여러 패키지를 묶는다"
    ],
    "answer": "하나의 타입 참조로 다양한 실제 객체를 다룬다",
    "explanation": "다형성은 상위 타입으로 하위 타입 인스턴스를 참조하여 공통 인터페이스로 동작시키는 개념이다.",
    "level": "NORMAL",
    "categoryId": 1
  },
  {
    "question": "다음 중 Checked Exception은?",
    "choices": [
      "NullPointerException",
      "ArithmeticException",
      "IOException",
      "IllegalArgumentException"
    ],
    "answer": "IOException",
    "explanation": "IOException은 반드시 처리(throws 또는 try-catch)가 필요한 Checked Exception이다.",
    "level": "NORMAL",
    "categoryId": 1
  },
  {
    "question": "try-with-resources가 적용되는 인터페이스는?",
    "choices": [
      "Serializable",
      "Closeable/AutoCloseable",
      "Cloneable",
      "Iterable"
    ],
    "answer": "Closeable/AutoCloseable",
    "explanation": "AutoCloseable을 구현한 자원은 try-with-resources로 자동 close 가능하다.",
    "level": "NORMAL",
    "categoryId": 1
  },
  {
    "question": "StringBuilder를 사용하는 주된 이유는?",
    "choices": [
      "스레드 안전",
      "불변성",
      "가변 버퍼로 성능 향상",
      "네트워크 전송"
    ],
    "answer": "가변 버퍼로 성능 향상",
    "explanation": "문자열 연결 시 불변 String 대신 가변 StringBuilder를 사용하면 효율적이다.",
    "level": "NORMAL",
    "categoryId": 1
  },
  {
    "question": "final 키워드에 대한 설명으로 옳은 것은?",
    "choices": [
      "클래스만 적용",
      "변수, 메서드, 클래스 모두 적용 가능",
      "지역 변수에는 불가",
      "상속 강제"
    ],
    "answer": "변수, 메서드, 클래스 모두 적용 가능",
    "explanation": "final 변수는 재할당 불가, 메서드는 오버라이드 불가, 클래스는 상속 불가를 의미한다.",
    "level": "NORMAL",
    "categoryId": 1
  },
  {
    "question": "Collections.unmodifiableList(list)의 특징은?",
    "choices": [
      "원본도 불변으로 만든다",
      "읽기 전용 뷰를 반환한다",
      "정렬 상태를 보장한다",
      "스레드 안전을 보장한다"
    ],
    "answer": "읽기 전용 뷰를 반환한다",
    "explanation": "수정 연산 시 UnsupportedOperationException이 발생하는 읽기 전용 뷰를 제공한다.",
    "level": "NORMAL",
    "categoryId": 1
  },
  {
    "question": "HashMap의 key로 부적절한 것은?",
    "choices": [
      "불변 객체",
      "equals/hashCode 일관성 유지 객체",
      "변경 가능한 가변 객체",
      "String"
    ],
    "answer": "변경 가능한 가변 객체",
    "explanation": "키는 equals/hashCode가 안정적으로 유지되어야 하므로 가변 객체는 위험하다.",
    "level": "NORMAL",
    "categoryId": 1
  },
  {
    "question": "다음 중 인터페이스의 default 메서드 설명으로 옳은 것은?",
    "choices": [
      "구현체에서만 선언 가능",
      "인터페이스에서 구현이 있는 인스턴스 메서드",
      "static만 허용",
      "추상 메서드만 가짐"
    ],
    "answer": "인터페이스에서 구현이 있는 인스턴스 메서드",
    "explanation": "default 메서드는 인터페이스에서 본문을 제공하는 인스턴스 메서드다.",
    "level": "NORMAL",
    "categoryId": 1
  },
  {
    "question": "equals와 hashCode 계약에 대한 설명으로 옳은 것은?",
    "choices": [
      "equals가 같아도 hashCode는 달라야 한다",
      "equals가 같으면 hashCode도 같아야 한다",
      "둘은 무관하다",
      "hashCode만 같으면 된다"
    ],
    "answer": "equals가 같으면 hashCode도 같아야 한다",
    "explanation": "equals가 true이면 같은 hashCode를 반환해야 컬렉션 동작이 보장된다.",
    "level": "NORMAL",
    "categoryId": 1
  },
  {
    "question": "List와 Set의 가장 큰 차이는?",
    "choices": [
      "정렬 여부",
      "중복 허용 여부",
      "스레드 안전 여부",
      "인덱스 기반 여부만 동일"
    ],
    "answer": "중복 허용 여부",
    "explanation": "List는 중복 허용, Set은 중복을 허용하지 않는다. 또한 List는 인덱스 기반이다.",
    "level": "NORMAL",
    "categoryId": 1
  },
  {
    "question": "String과 StringBuilder의 차이로 옳은 것은?",
    "choices": [
      "둘 다 불변",
      "둘 다 가변",
      "String은 불변, StringBuilder는 가변",
      "String은 가변, StringBuilder는 불변"
    ],
    "answer": "String은 불변, StringBuilder는 가변",
    "explanation": "String은 수정 시 새 객체를 생성하고, StringBuilder는 내부 버퍼를 변경한다.",
    "level": "NORMAL",
    "categoryId": 1
  },
  {
    "question": "Optional의 올바른 사용 예는?",
    "choices": [
      "필드로 저장",
      "메서드 파라미터로 사용",
      "반환 타입으로 사용",
      "컬렉션 원소로 저장"
    ],
    "answer": "반환 타입으로 사용",
    "explanation": "Optional은 반환값에서 null 회피를 위해 사용하며, 필드/파라미터/원소로는 권장되지 않는다.",
    "level": "NORMAL",
    "categoryId": 1
  },
  {
    "question": "Thread-safe한 컬렉션이 아닌 것은?",
    "choices": [
      "Vector",
      "ConcurrentHashMap",
      "CopyOnWriteArrayList",
      "ArrayList"
    ],
    "answer": "ArrayList",
    "explanation": "ArrayList는 동기화를 제공하지 않는다. 필요하면 외부에서 동기화해야 한다.",
    "level": "NORMAL",
    "categoryId": 1
  },
  {
    "question": "ExecutorService의 shutdown() 호출 의미는?",
    "choices": [
      "즉시 종료 및 작업 취소",
      "새 작업은 거부, 진행 중 작업은 완료",
      "JVM 종료",
      "스레드 우선순위 변경"
    ],
    "answer": "새 작업은 거부, 진행 중 작업은 완료",
    "explanation": "shutdown은 신규 제출을 막고, 이미 제출된 작업은 완료되게 한다.",
    "level": "NORMAL",
    "categoryId": 1
  },
  {
    "question": "Stream의 중간 연산이 아닌 것은?",
    "choices": ["map", "filter", "collect", "distinct"],
    "answer": "collect",
    "explanation": "collect는 종단 연산이며, map/filter/distinct는 중간 연산이다.",
    "level": "NORMAL",
    "categoryId": 1
  },
  {
    "question": "synchronized 키워드의 역할은?",
    "choices": [
      "가비지 컬렉션 강제",
      "스레드 간 임계 구역 보호",
      "JIT 최적화 비활성",
      "메서드 인라인"
    ],
    "answer": "스레드 간 임계 구역 보호",
    "explanation": "동기화 블록/메서드를 통해 한 시점에 하나의 스레드만 진입하도록 보장한다.",
    "level": "NORMAL",
    "categoryId": 1
  },

  {
    "question": "JVM 메모리 중 스레드마다 별도로 할당되는 영역은?",
    "choices": ["Heap", "Stack", "Method Area", "Metaspace"],
    "answer": "Stack",
    "explanation": "각 스레드는 자신만의 호출 스택(Stack)을 가진다. 객체 인스턴스는 주로 Heap에 있다.",
    "level": "HARD",
    "categoryId": 1
  },
  {
    "question": "JIT(Just-In-Time) 컴파일러의 역할로 옳은 것은?",
    "choices": [
      "바이트코드를 즉시 기계어로 변환해 최적화 실행",
      "클래스 로딩",
      "메모리 관리",
      "스케줄링"
    ],
    "answer": "바이트코드를 즉시 기계어로 변환해 최적화 실행",
    "explanation": "JIT은 실행 중 자주 호출되는 바이트코드를 네이티브 코드로 컴파일해 성능을 높인다.",
    "level": "HARD",
    "categoryId": 1
  },
  {
    "question": "Java Memory Model(JMM)에서 volatile의 의미는?",
    "choices": [
      "원자성 제공",
      "가시성 보장 및 재정렬 억제",
      "락 대체",
      "스케줄링 향상"
    ],
    "answer": "가시성 보장 및 재정렬 억제",
    "explanation": "volatile 변수는 쓰기-읽기 시 가시성을 보장하고 특정 재정렬을 막지만 원자적 복합 연산을 보장하지는 않는다.",
    "level": "HARD",
    "categoryId": 1
  },
  {
    "question": "happens-before 관계를 보장하지 않는 것은?",
    "choices": [
      "synchronized 블록의 락 해제→획득",
      "volatile 쓰기→읽기",
      "Thread.start()→스레드 본문",
      "System.gc() 호출"
    ],
    "answer": "System.gc() 호출",
    "explanation": "GC 호출은 happens-before 보장을 제공하지 않는다.",
    "level": "HARD",
    "categoryId": 1
  },
  {
    "question": "equals를 재정의할 때 반드시 같이 재정의해야 하는 메서드는?",
    "choices": ["toString", "hashCode", "clone", "finalize"],
    "answer": "hashCode",
    "explanation": "equals/hashCode 계약을 만족하려면 함께 재정의해야 한다.",
    "level": "HARD",
    "categoryId": 1
  },
  {
    "question": "ConcurrentHashMap에서 동시성 제어 방식에 대한 설명으로 옳은 것은?",
    "choices": [
      "전체 맵 전역 락",
      "세그먼트 방식/버킷 락 혹은 CAS 등 조합",
      "단일 스레드 전용",
      "읽기 차단"
    ],
    "answer": "세그먼트 방식/버킷 락 혹은 CAS 등 조합",
    "explanation": "구현 버전에 따라 세그먼트/버킷 락/CAS 등으로 동시성을 높인다.",
    "level": "HARD",
    "categoryId": 1
  },
  {
    "question": "Java 8 Stream의 병렬 스트림(parallelStream)에 대한 설명으로 옳은 것은?",
    "choices": [
      "항상 순차보다 빠르다",
      "데이터 분할 비용과 순서 보장이 성능에 영향",
      "락을 강제한다",
      "가비지 컬렉션을 비활성화"
    ],
    "answer": "데이터 분할 비용과 순서 보장이 성능에 영향",
    "explanation": "병렬 스트림은 작업 특성, 데이터 크기, 순서 유무 등에 따라 성능 이점이 달라진다.",
    "level": "HARD",
    "categoryId": 1
  },
  {
    "question": "class loader 계층 구조에서 부트스트랩→확장→애플리케이션 순으로 로딩되는 원칙은?",
    "choices": [
      "위임 모델(Parent Delegation)",
      "프록시 패턴",
      "옵저버 패턴",
      "싱글톤 패턴"
    ],
    "answer": "위임 모델(Parent Delegation)",
    "explanation": "상위 로더에 먼저 위임해 보안과 일관성을 확보하는 모델이다.",
    "level": "HARD",
    "categoryId": 1
  },
  {
    "question": "synchronized보다 세밀한 락 제어와 조건 대기를 제공하는 클래스는?",
    "choices": ["Object", "ReentrantLock", "Semaphore", "CountDownLatch"],
    "answer": "ReentrantLock",
    "explanation": "ReentrantLock은 조건 객체(Condition)와 공정성 등 고급 기능을 제공한다.",
    "level": "HARD",
    "categoryId": 1
  },
  {
    "question": "Fork/Join 프레임워크의 목적은?",
    "choices": [
      "I/O 대기 단축",
      "작업을 분할/정복해 병렬 처리",
      "락을 제거",
      "네트워킹 향상"
    ],
    "answer": "작업을 분할/정복해 병렬 처리",
    "explanation": "큰 작업을 작은 작업으로 재귀적으로 나누어 병렬 수행한다.",
    "level": "HARD",
    "categoryId": 1
  },
  {
    "question": "immutability가 멀티스레드에서 유리한 이유는?",
    "choices": [
      "락이 필요 없어 상태 경합이 없다",
      "GC가 안 일어난다",
      "캐시 미스 증가",
      "스케줄링 고정"
    ],
    "answer": "락이 필요 없어 상태 경합이 없다",
    "explanation": "불변 객체는 동기화 없이도 안전하게 공유 가능하다.",
    "level": "HARD",
    "categoryId": 1
  },
  {
    "question": "CompletableFuture에서 thenCompose와 thenApply의 차이는?",
    "choices": [
      "둘 다 동일",
      "thenCompose는 평탄화, thenApply는 값 변환",
      "thenCompose는 값 변환, thenApply는 평탄화",
      "둘 다 블로킹"
    ],
    "answer": "thenCompose는 평탄화, thenApply는 값 변환",
    "explanation": "thenCompose는 중첩된 Future를 평탄화하고, thenApply는 결과 값을 변환한다.",
    "level": "HARD",
    "categoryId": 1
  },
  {
    "question": "record(자바 16 정식)의 주요 목적은?",
    "choices": [
      "동적 프록시",
      "불변적 데이터 캐리어 간결 선언",
      "스레드 동기화",
      "GC 튜닝"
    ],
    "answer": "불변적 데이터 캐리어 간결 선언",
    "explanation": "record는 필드를 기반으로 equals/hashCode/toString 등을 자동 생성하는 데이터 전용 클래스다.",
    "level": "HARD",
    "categoryId": 1
  },
  {
    "question": "sealed 클래스의 목적은?",
    "choices": [
      "상속 금지",
      "상속 허용 범위를 제한해 계층 제어",
      "동기화 제공",
      "직렬화 지원"
    ],
    "answer": "상속 허용 범위를 제한해 계층 제어",
    "explanation": "sealed는 어떤 클래스/인터페이스가 상속/구현 가능한지를 제한한다.",
    "level": "HARD",
    "categoryId": 1
  },
  {
    "question": "VarHandle의 역할은?",
    "choices": [
      "리플렉션 대체 I/O",
      "저수준 메모리/동시성 연산에 대한 안전한 핸들",
      "GC 강제",
      "클래스 로딩"
    ],
    "answer": "저수준 메모리/동시성 연산에 대한 안전한 핸들",
    "explanation": "sun.misc.Unsafe 대체로 도입되어 메모리 장벽/원자 연산 등을 안전하게 제공한다.",
    "level": "HARD",
    "categoryId": 1
  },
  {
    "question": "G1 GC의 주요 목표는?",
    "choices": [
      "Stop-the-world 제거",
      "예측 가능한 짧은 일시정지 시간",
      "CMS 완전 대체 불가",
      "스캐빈징 제거"
    ],
    "answer": "예측 가능한 짧은 일시정지 시간",
    "explanation": "G1은 힙을 영역으로 나눠 병렬/동시 수집을 통해 예측 가능한 짧은 STW를 지향한다.",
    "level": "HARD",
    "categoryId": 1
  },
  {
    "question": "Escape Analysis 최적화의 효과는?",
    "choices": [
      "힙 할당 증가",
      "스택 할당/동기화 제거 가능",
      "JIT 비활성화",
      "클래스 로딩 가속"
    ],
    "answer": "스택 할당/동기화 제거 가능",
    "explanation": "객체가 스레드 밖으로 탈출하지 않으면 스택 할당 및 락 제거가 가능해진다.",
    "level": "HARD",
    "categoryId": 1
  },
  {
    "question": "java.util.concurrent 패키지의 주요 제공 기능은?",
    "choices": [
      "파서",
      "동시성 유틸리티(락, 큐, 실행자 등)",
      "그래픽",
      "사운드"
    ],
    "answer": "동시성 유틸리티(락, 큐, 실행자 등)",
    "explanation": "스레드 풀, 락, 동시 컬렉션 등 다양한 동시성 도구를 제공한다.",
    "level": "HARD",
    "categoryId": 1
  },
  {
    "question": "Memory Barrier(메모리 장벽)의 목적은?",
    "choices": [
      "캐시 무효화만",
      "명령/메모리 접근 순서 제어",
      "GC 강제",
      "클래스 로딩"
    ],
    "answer": "명령/메모리 접근 순서 제어",
    "explanation": "CPU/컴파일러 재정렬을 제어하여 가시성과 순서를 보장한다.",
    "level": "HARD",
    "categoryId": 1
  },
  {
    "question": "패턴 매칭 for instanceof 의 장점은?",
    "choices": [
      "성능 저하",
      "캐스팅 코드 감소와 가독성 향상",
      "동기화 제공",
      "예외 제거"
    ],
    "answer": "캐스팅 코드 감소와 가독성 향상",
    "explanation": "instanceof 검사와 캐스팅을 결합해 보일러플레이트를 줄인다.",
    "level": "HARD",
    "categoryId": 1
  },
  {
    "question": "Text Blocks(멀티라인 문자열)의 장점은?",
    "choices": [
      "성능 향상",
      "문자열 리터럴에 줄바꿈/따옴표를 간결히 표현",
      "GC 최적화",
      "스레드 안전 보장"
    ],
    "answer": "문자열 리터럴에 줄바꿈/따옴표를 간결히 표현",
    "explanation": "세 개의 따옴표로 감싸서 멀티라인 문자열을 쉽게 작성할 수 있다.",
    "level": "HARD",
    "categoryId": 1
  }
]